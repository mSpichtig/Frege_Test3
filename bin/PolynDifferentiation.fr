

module examples.PolynDifferentiation where
import frege.prelude.Math

{--- 
	The programm implements methods for numerical differentiation and numerical intregration from the numerics textbook of
	G체nter B채rwolff, 2016, Numerik f체r Ingenieure, Physiker und Informatiker, Springer Spektrum. We deviate from this template 
	in that we generate interpolation polynomals as described in https://hackage.haskell.org/package/polynomial-0.7.3/docs/src/Math-Polynomial-Interpolation.html#polyInterp.

	Approximate the first derivative of function f at x-value x. For example, the derivate of the square root function at x0 = 1 can 	be approximated by	> firstDerivative sqrt 1 [0.3, 0.2, 0.15, 0.1]	an more accurate approximation value is attained with the instruction  		> firstDerivative sqrt 1 [0.03, 0.02, 0.015, 0.01]-}
-- I don't know why the eclipse plugin decided that the following type declaration is wrong or a comment-- the plugin was OK with it all the time, but eventually started to show spooky behaviorfirstDerivative :: (Double->Double) -> Double -> [Double] -> Double
firstDerivative f x hValues = polyInterp' (zip hValues $ map (f0 x) hValues) 0
  where
     f0 x h = (f (x+h) - f x)/(h)-- Approximate the second derivate of function f at x-value x. For example,
-- > secondDerivative sin (pi/4) [0.3,0.2,0.15,0.1]
-- corresponds to the example in B채rwolff's book (p. 131)
secondDerivative  :: (Double->Double) -> Double -> [Double] -> Double
secondDerivative f x hValues = polyInterp' (zip hValues $ map (f0 x) hValues) 0
  where
     f0 x h = (f (x+h) - 2*f x + f (x-h))/(h*h)


simpson :: (Double -> Double) -> Double -> Double -> Int -> Double      
simpson f a b n = h*(f a + 4 * f (a + h) + f b + 2* sum)/3
  where
   zweiN = fromIntegral $ 2*n
   h =  (b - a) / zweiN 
   sum = fold (\c i -> let k = fromIntegral i in c + f (a+2*k*h) + 2 * f (a + (2*k+1) *h)) 0.0 [1 .. (n-1)]

gaussTschebyscheffQuadratur :: (Double -> Double) -> Double -> Double -> Int -> Double
gaussTschebyscheffQuadratur f a b n = integral  * pi * (b - a) / (zweiN)
 where
  zweiN = fromIntegral $ 2*n
  integral = fold (\c i -> let x = cos ((2*(fromIntegral i)-1)*pi / (zweiN)) in (c + f (x*(b-a)*0.5+(a+b)*0.5) * sqrt (1 - x*x) ) ) 0.0 [1 .. n] 

-- Generate a polynomial using the tableau generated by Neville's algorithm.
polyInterp' :: Real a => [(a,a)] -> a -> a
polyInterp' xys = head . last . neville' xys

neville' :: Real a => [(a,a)] -> a -> [[a]]
neville' xys x = ys : zipo zipxs zipys
   where 
     (xs,ys) = unzip xys
     zipxs = zip (init xs) (tail xs)
     zipys = zip (init ys) (tail ys)
     zipo [] _ = []
     zipo zx zy = bs : zipo zzx zzy 
      where
       bs = map (\((x1,x2),(p1,p2)) -> ((x-x2)*p1-(x-x1)*p2) / (x1 - x2) ) $ zip zx zy
       (fzx,szx) = unzip zx
       zzx = zip (init fzx) (tail szx) -- (init $ map fst zx) (tail $ map snd zx) 
       zzy = zip (init bs) (tail bs)   
 
 
